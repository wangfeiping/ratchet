use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::process::exit;

use ratchet_version::VERSION;

use clap::{App, Arg, ArgMatches};

use log::{error, info, warn};
use log4rs;
use log::LevelFilter;
use log4rs::append::console::ConsoleAppender;
use log4rs::append::file::FileAppender;
use log4rs::encode::pattern::PatternEncoder;
use log4rs::config::{Appender, Config, Logger, Root};

#[macro_use] extern crate lazy_static;
#[macro_use] extern crate prometheus;
use prometheus::{IntCounter, TextEncoder, Encoder};

lazy_static! {
    static ref HIGH_FIVE_COUNTER: IntCounter =
        register_int_counter!("high_five", "Number of high five received").unwrap();
    static ref NOT_FOUND_COUNTER: IntCounter =
        register_int_counter!("not_found", "Not found").unwrap();
}

const CRLF: &str = "\r\n";

fn init_log() {
    let stdout = ConsoleAppender::builder()
        .encoder(Box::new(PatternEncoder::new("[Console] {d} - {l} -{t} - {m}{n}")))
        .build();

    let file = FileAppender::builder()
        .encoder(Box::new(PatternEncoder::new("[File] {d} - {l} - {t} - {m}{n}")))
        .build("log/test.log")
        .unwrap();

    let config = Config::builder()
        .appender(Appender::builder().build("stdout", Box::new(stdout)))
        .appender(Appender::builder().build("file", Box::new(file)))
        .logger(Logger::builder()
            .appender("file")
            .additive(false)
            .build("app", LevelFilter::Info))
        .build(Root::builder().appender("stdout").build(LevelFilter::Info))
        .unwrap();

    log4rs::init_config(config).unwrap();
}

fn main() {
    let ret = log4rs::init_file(
        "./log4rs.yaml", Default::default());
    match ret {
        Ok(ret) => ret,
        Err(e) => {
            init_log();
            error!("{}", e)
        }
    };

    // Parse the CLI parameters.
    let matches = App::new("Ratchet")
        .version(VERSION.replace("Ratchet/", "").as_str())
        .author("wangfeiping <wangfeiping@outlook.com>")
        .setting(clap::AppSettings::ColoredHelp)
        .about(
            "net watcher \
             developed using rust",
        )
        .long_version(
            format!(
                "{}\n\
                 Rust 2018",
                VERSION.replace("Ratchet/", ""),
            ).as_str()
        )
        .arg(
            Arg::with_name("log-level")
                .long("log-level")
                .value_name("LEVEL")
                .help("The verbosity level for emitting logs.")
                .takes_value(true)
                .possible_values(&["info", "debug", "trace", "warn", "error", "crit"])
                .global(true)
                .default_value("info"),

        )
        .get_matches();

    let result = run(&matches);

    // `std::process::exit` does not run destructors so we drop manually.
    drop(matches);

    // Return the appropriate error code.
    match result {
        Ok(()) => exit(0),
        Err(e) => {
            error!("{}", e);
            drop(e);
            exit(1)
        }
    }
}

fn run(
    matches: &ArgMatches,
) -> Result<(), String> {
    let log_level = matches
        .value_of("log-level")
        .ok_or("Expected --log-level flag")?;

    println!("log-level: {}", log_level);
    info!("booting up");

    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        thread::spawn(|| handle_connection(stream));
    }
    
    Ok(())
}

fn handle_index() -> (String, String) {
    let mut contents= String::new();
    contents.push_str("Hello!");
    contents.push_str(
        format!(
            " {}\n", VERSION.replace("Ratchet/", "")
        ).as_str());
    HIGH_FIVE_COUNTER.inc();
    info!("{}", contents);
    (contents, status(200, "OK"))
}

fn handle_404() -> (String, String) {
    let msg = "404 Not Found!";
    NOT_FOUND_COUNTER.inc();
    warn!("{}", msg);
    (msg.to_string(), status(404, "OK"))
}

fn handle_metrics() -> (String, String) {
    let mut buffer = Vec::new();
    let encoder = TextEncoder::new();

    // Gather the metrics.
    let metric_families = prometheus::gather();
    // Encode them to send.
    encoder.encode(&metric_families, &mut buffer).unwrap();
    let output = String::from_utf8(buffer.clone()).unwrap();

    (output, status(200, "OK"))
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer= [0; 4096];
    stream.read(&mut buffer).unwrap();

    let _matched = |route: &str| matched(&buffer, route);
    let _write = |(contents, status)| write(stream, contents, status);

    if _matched("/") {
        _write(handle_index());
    }else if _matched("/metrics") {
        _write(handle_metrics());
    } else {
        _write(handle_404());
    }
}

fn matched(buffer: &[u8; 4096], route: &str) -> bool {
    let s = format!("GET {} HTTP/1.1{}", route, CRLF);
    buffer.starts_with(s.as_bytes())
}

fn status(code: i32, text: &str) -> String {
    format!("HTTP/1.1 {} {}{}", code, text, CRLF)
}

fn write(mut stream: TcpStream, contents: String, status: String) {
    let content_type = format!("Content-Type: text/html;charset=utf-8{}", CRLF);
    let server = format!("Server: Rust{}", CRLF);
    let content_length = format!("Content-Length: {}{}", contents.as_bytes().len(), CRLF);
    let response = format!(
        "{0}{1}{2}{3}{4}{5}",
        status, server, content_type, content_length, CRLF, contents
    );
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}

